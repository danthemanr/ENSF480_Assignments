/*
* File Name: dictionaryList.h
* Assignment: Lab 2, Exercise A
* Lab Section: B01
* Completed by: Daniel Rey, Aly Farouz
* Submission Date: Sept 22, 2022
*/

#ifndef DICTIONARY_H
#define DICTIONARY_H
#include <iostream>
#include <string>
using namespace std;

// class DictionaryList: GENERAL CONCEPTS
//
//    key/datum pairs are ordered.  The first pair is the pair with
//    the lowest key, the second pair is the pair with the second
//    lowest key, and so on.  This implies that you must be able to
//    compare two keys with the < operator.
//
//    Each DictionaryList object has a "cursor" that is either attached
//    to a particular key/datum pair or is in an "off-list" state, not
//    attached to any key/datum pair.  If a DictionaryList is empty, the
//    cursor is automatically in the "off-list" state.

// You can edit this typedef to change the datum types, if necessary (it is not necessary
// for this lab exercise).

typedef string Datum;

// THE NODE TYPE
//    In this exercise the node type is a class, that has a ctor.
//    Data members of Node are private, and class DictionaryList
//    is declared as a friend. For details on the friend keyword refer to your
//    lecture notes.

class Node {
    friend class DictionaryList; // makeing DictionaryList a fried to have access to private data member in a node.
private:
    int keyM;
    Datum datumM;
    Node *nextM;
    
    // This ctor should be convenient in insert and copy operations.
    Node(const int& keyA, const Datum& datumA, Node *nextA);
};

class DictionaryList {
public:
    DictionaryList();
    DictionaryList(const DictionaryList& source);
    DictionaryList& operator =(const DictionaryList& rhs);
    ~DictionaryList();
    
    int size() const;
    // PROMISES: Returns number of keys in the table.
    
    int cursor_ok() const;
    // PROMISES:
    //   Returns 1 if the cursor is attached to a key/datum pair,
    //   and 0 if the cursor is in the off-list state.
    
    const int& cursor_key() const;
    // REQUIRES: cursor_ok()
    // PROMISES: Returns key of key/datum pair to which cursor is attached.
    
    Datum& cursor_datum() const; //Note: I removed const from the front because exAmain is trying to edit this
    // REQUIRES: cursor_ok()
    // PROMISES: Returns datum of key/datum pair to which cursor is attached.
    
    void insert(const int& keyA, const Datum& datumA);
    // PROMISES:
    //   If keyA matches a key in the table, the datum for that
    //   key is set equal to datumA.
    //   If keyA does not match an existing key, keyA and datumM are
    //   used to create a new key/datum pair in the table.
    //   In either case, the cursor goes to the off-list state.
    
    void remove(const int& keyA);
    // PROMISES:
    //   If keyA matches a key in the table, the corresponding
    //   key/datum pair is removed from the table.
    //   If keyA does not match an existing key, the table is unchanged.
    //   In either case, the cursor goes to the off-list state.
    
    void find(const int& keyA);
    // PROMISES:
    //   If keyA matches a key in the table, the cursor is attached
    //   to the corresponding key/datum pair.
    //   If keyA does not match an existing key, the cursor is put in
    //   the off-list state.
    
    void go_to_first();
    // PROMISES: If size() > 0, cursor is moved to the first key/datum pair
    //   in the table.
    
    void step_fwd();
    // REQUIRES: cursor_ok()
    // PROMISES:
    //   If cursor is at the last key/datum pair in the list, cursor
    //   goes to the off-list state.
    //   Otherwise the cursor moves forward from one pair to the next.
    
    void make_empty();
    // PROMISES: size() == 0.
    
    friend ostream& operator << (ostream& os, DictionaryList& dl);
    //doesn't need to be a friend, but I have to declare it somehwere
    
    bool operator !=(const DictionaryList& rhs);
    bool operator >(const DictionaryList& rhs);
    bool operator <(const DictionaryList& rhs);
    bool operator <=(const DictionaryList& rhs);
    bool operator >=(const DictionaryList& rhs);
    
    Datum operator[](int i) const;
    
private:
    int sizeM;
    Node *headM;    // a pointer that points to the first node in the list. Or is set to zero,
    Node *cursorM;  // a pointer that can be used to traverse through list. Or set to zero, if not used.
#if 0
    void destroy();
    // REQUIRES: A helper function that deallocate all nodes, set headM to zero.
    
    void copy(const DictionaryList& source);
    // REQUIRES: A helper function to establishe *this as a copy of source.  Cursor of *this will
    // point to the twin of whatever the source's cursor points to.
#endif
};

#endif



/*
* File Name: dictionaryList.cpp
* Assignment: Lab 2, Exercise A
* Lab Section: B01
* Completed by: Daniel Rey, Aly Farouz
* Submission Date: Sept 22, 2022
*/

#include <assert.h>
#include <iostream>
#include <stdlib.h>
#include "dictionaryList.h"
using namespace std;

Node::Node(const int& keyA, const Datum& datumA, Node *nextA)
: keyM(keyA), datumM(datumA), nextM(nextA)
{
}

DictionaryList::DictionaryList()
: sizeM(0), headM(0), cursorM(0)
{
}

int DictionaryList::size() const
{
    return sizeM;
}

int DictionaryList::cursor_ok() const
{
    return cursorM != 0;
}

const int& DictionaryList::cursor_key() const
{
    assert(cursor_ok());
    return cursorM->keyM;
}

Datum& DictionaryList::cursor_datum() const
{
    assert(cursor_ok());
    return cursorM->datumM;
}

void DictionaryList::insert(const int& keyA, const string& datumA)
{
    // Add new node at head?
    if (headM == 0 || keyA < headM->keyM) {
        headM = new Node(keyA, datumA, headM);
        sizeM++;
    }
    
    // Overwrite datum at head?
    else if (keyA == headM->keyM)
        headM->datumM = datumA;
    
    // Have to search ...
    else {
        
        //POINT ONE
        
        // if key is found in list, just overwrite data;
        for (Node *p = headM; p !=0; p = p->nextM)
        {
            if(keyA == p->keyM)
            {
                p->datumM = datumA;
                return;
            }
        }
        
        //OK, find place to insert new node ...
        Node *p = headM ->nextM;
        Node *prev = headM;
        
        while(p !=0 && keyA >p->keyM)
        {
            prev = p;
            p = p->nextM;
        }
        
        prev->nextM = new Node(keyA, datumA, p);
        sizeM++;
    }
    cursorM = NULL;
    
}

void DictionaryList::remove(const int& keyA)
{
    if (headM == 0 || keyA < headM -> keyM)
        return;
    
    Node *doomed_node = 0;
    
    if (keyA == headM-> keyM) {
        doomed_node = headM;
        headM = headM->nextM;
        
        // POINT TWO
    }
    else {
        Node *before = headM;
        Node *maybe_doomed = headM->nextM;
        while(maybe_doomed != 0 && keyA > maybe_doomed-> keyM) {
            before = maybe_doomed;
            maybe_doomed = maybe_doomed->nextM;
        }
        
        if (maybe_doomed != 0 && maybe_doomed->keyM == keyA) {
            doomed_node = maybe_doomed;
            before->nextM = maybe_doomed->nextM;
        }
        
        
    }
    if(doomed_node == cursorM)
        cursorM = 0;
    
    delete doomed_node;           // Does nothing if doomed_node == 0.
    sizeM--;
}

void DictionaryList::go_to_first()
{
    cursorM = headM;
}

void DictionaryList::step_fwd()
{
    assert(cursor_ok());
    cursorM = cursorM->nextM;
}

// The following functions are supposed to be completed by the stuents, as part
// of the exercise B. the given code for this fucntion are just place-holders
// in order to allow successful linking when you're esting insert and remove.
// Replace them with the definitions that work.

DictionaryList::DictionaryList(const DictionaryList& source)
  : sizeM(source.sizeM), headM(0), cursorM(source.cursorM)
{
  if (sizeM!=0)
  {
    Node *c = source.headM;
    Node *p, *prev = headM = new Node(c->keyM, c->datumM, NULL);
    for(c = c->nextM; c!=NULL; c = c->nextM)
    {
      p = new Node(c->keyM, c->datumM, NULL);
      prev = prev->nextM = p;
    }
  }
}

DictionaryList& DictionaryList::operator =(const DictionaryList& rhs)
{
  if (this != &rhs) {
    if (sizeM>=rhs.sizeM)
    {
      if (headM!=NULL)
      {
        Node *c, *p = headM;
        for(c=rhs.headM; c!=NULL; p=p->nextM)
        {
          p->keyM = c->keyM;
          p->datumM = c->datumM;
          c = c->nextM;
        }
        Node *next = p->nextM;
        p->nextM = NULL;
        while(next!=NULL)
        {
          p = next;
          next = next->nextM;
          delete p;
        }
      }
    }
    else
    {
      Node *prev, *p, *c = rhs.headM;
      if (headM==NULL)
      {
        prev = headM = new Node(c->keyM, c->datumM, NULL);
        c = c->nextM;
      }
      else
      {
        for(p=headM; p!=NULL; p=p->nextM)
        {
          p->keyM = c->keyM;
          p->datumM = c->datumM;
          c = c->nextM;
          prev = p;
        }
      }
      while(c!=NULL)
      {
        p = new Node(c->keyM, c->datumM, NULL);
        prev = prev->nextM = p;
        c = c->nextM;
      }
    }
    cursorM = rhs.cursorM;
    sizeM = rhs.sizeM;
  }
  return *this;
}

DictionaryList::~DictionaryList()
{
  for(Node *prev, *p=headM; p!=NULL;)
  {
    prev = p;
    p = p->nextM;
    delete prev;
  }
}

void DictionaryList::find(const int& keyA)
{
    for (Node *p = headM; p != 0; p=p->nextM)
        if (keyA == p->keyM)
        {
            cout << "'" << keyA <<"' was found with datum value " << p->datumM.c_str() << ".\n";
            cursorM = p;
            return;
        }
    cout << "'" << keyA <<"' was not found.\n";
    cursorM = 0;
}

void DictionaryList::make_empty()
{
  for(Node *prev, *p=headM; p!=NULL;)
  {
    prev = p;
    p = p->nextM;
    delete prev;
  }
  cursorM = headM = 0;
  sizeM = 0;
}

ostream& operator << (ostream& os, DictionaryList& dl)
{
    os << dl.cursor_datum();
    return os;
}
bool DictionaryList::operator !=(const DictionaryList& rhs)
{
   return !(this->cursor_datum() == rhs.cursor_datum());
}
bool DictionaryList::operator >(const DictionaryList& rhs)
{
   return this->cursor_datum() > rhs.cursor_datum();
}
bool DictionaryList::operator <(const DictionaryList& rhs)
{
   return this->cursor_datum() < rhs.cursor_datum();
}
bool DictionaryList::operator <=(const DictionaryList& rhs)
{
   return !(this->cursor_datum() > rhs.cursor_datum());
}
bool DictionaryList::operator >=(const DictionaryList& rhs)
{
   return !(this->cursor_datum() < rhs.cursor_datum());
}
//above few functions were implemented by Farouz
Datum DictionaryList::operator[](int i)const{ //will cause an error if i >= sizeM
    Node* p=headM;
    while(i>0){
        p=p->nextM;
        i--;
    }
    return p->datumM;
}



/*
* File Name: Lab2_exAmain.cpp
* Assignment: Lab 2, Exercise A
* Lab Section: B01
* Completed by: Daniel Rey, Aly Farouz
* Submission Date: Sept 22, 2022
*/

#include <assert.h>
#include <iostream>
#include "dictionaryList.h"

using namespace std;

DictionaryList dictionary_tests();

void test_copying();

void print(DictionaryList& dl);

void test_finding(DictionaryList& dl);

void test_operator_overloading(DictionaryList& dl);

int main()
{
  DictionaryList dl = dictionary_tests();
#if 1
 test_operator_overloading(dl);
#endif
  return 0;
}
//g++ -Wall Lab2_exAmain.cpp dictionaryList.cpp -o exA.exe

DictionaryList dictionary_tests()
{
  
  DictionaryList dl;

  assert(dl.size() == 0);
  cout << "\nPrinting list just after its creation ...\n";
  print(dl);

  // Insert using new keys.
  dl.insert(8001,"Dilbert");
  dl.insert(8002,"Alice");
  dl.insert(8003,"Wally");
  assert(dl.size() == 3);
  cout << "\nPrinting list after inserting 3 new keys ...\n";
  print(dl);
  dl.remove(8002);
  dl.remove(8001);
  dl.insert(8004,"PointyHair");
  assert(dl.size() == 2);
  cout << "\nPrinting list after removing two keys and inserting PointyHair ...\n";
  print(dl);

  // Insert using existing key.
  dl.insert(8003,"Sam");
  assert(dl.size() == 2);
  cout << "\nPrinting list after changing data for one of the keys ...\n";
  print(dl);

  dl.insert(8001,"Allen");
  dl.insert(8002,"Peter");
  assert(dl.size() == 4);
  cout << "\nPrinting list after inserting 2 more keys ...\n";
  print(dl);

  cout << "***----Finished dictionary tests---------------------------***\n\n";
  return dl;
}

void test_copying()
{
   DictionaryList one;

  // Copy an empty list.
  DictionaryList two;
  assert(two.size() == 0);

  // Copy a list with three entries and a valid cursor.
  one.insert(319,"Randomness");
  one.insert(315,"Shocks");
  one.insert(335,"ParseErrors");
  one.go_to_first();
  one.step_fwd();
    
  DictionaryList three(one);
    
  assert(three.cursor_datum() == "Randomness");
  one.remove(335);

  cout << "Printing list--keys should be 315, 319\n";
  print(one);
  
  cout << "Printing list--keys should be 315, 319, 335\n";
  print(three);

  // Assignment operator check.
  one = two = three = three;
  one.remove(319);
  two.remove(315);
  
  cout << "Printing list--keys should be 315, 335\n";
  print(one);

  cout << "Printing list--keys should be 319, 335\n";
  print(two);
  
  cout << "Printing list--keys should be 315, 319, 335\n";
  print(three);

  cout << "***----Finished tests of copying----------------------***\n\n";
}

void print(DictionaryList& dl)
{
  if (dl.size() == 0)
    cout << "  List is EMPTY.\n";
  for (dl.go_to_first(); dl.cursor_ok(); dl.step_fwd()) {
    cout << "  " << dl.cursor_key();
    cout << "  " << dl.cursor_datum().c_str() << '\n';
  }
}

void test_finding(DictionaryList& dl)
{
    
     // Pretend that a user is trying to look up names.
     cout << "\nLet's look up some names ...\n";
    
     dl.find(8001);
     if (dl.cursor_ok())
        cout << "  name for 8001 is: " << dl.cursor_datum().c_str() << ".\n";
     else
        cout << "  Sorry, I couldn't find 8001 in the list. \n" ;
    
     dl.find(8000);
     if (dl.cursor_ok())
        cout << "  name for 8000 is: " << dl.cursor_datum().c_str() << ".\n";
     else
        cout << "  Sorry, I couldn't find 8000 in the list. \n" ;
    
     dl.find(8002);
     if (dl.cursor_ok())
        cout << "  name for 8002 is: " << dl.cursor_datum().c_str() << ".\n";
     else
        cout << "  Sorry, I couldn't find 8002 in the list. \n" ;
    
     dl.find(8004);
     if (dl.cursor_ok())
        cout << "  name for 8004 is: " << dl.cursor_datum().c_str() << ".\n";
     else
        cout << "  Sorry, I couldn't find 8004 in the list. \n" ;
    
    cout << "***----Finished tests of finding -------------------------***\n\n";
}
#if 1
void test_operator_overloading(DictionaryList& dl)
{

    DictionaryList dl2 = dl;
    dl.go_to_first();
    dl.step_fwd();
    dl2.go_to_first();

    cout << "\nTestig a few comparison and insertion operators." << endl;
    
    // Needs to overload >= and << (insertion operator) in class Mystring
    //FIXME following block causes a segmentation fault
    if(dl.cursor_datum() >= (dl2.cursor_datum()))
       cout << endl << dl.cursor_datum() << " is greater than or equal " << dl2.cursor_datum();
    else
       cout << endl << dl2.cursor_datum() << " is greater than " << dl.cursor_datum();
    
    // Needs to overload <= for Mystring
    if(dl.cursor_datum() <= (dl2.cursor_datum()))
        cout << dl.cursor_datum() << " is less than or equal" << dl2.cursor_datum();
    else
        cout << endl << dl2.cursor_datum() << " is less than " << dl.cursor_datum();
    
    if(dl.cursor_datum() != (dl2.cursor_datum()))
        cout << endl << dl.cursor_datum() << " is not equal to " << dl2.cursor_datum();
    else
        cout << endl << dl2.cursor_datum() << " is equal to " << dl.cursor_datum();
    

    if(dl.cursor_datum() > (dl2.cursor_datum()))
        cout << endl << dl.cursor_datum() << " is greater than " << dl2.cursor_datum();
    else
        cout << endl << dl.cursor_datum() << " is not greater than " << dl2.cursor_datum();
    
    if(dl.cursor_datum() < (dl2.cursor_datum()))
        cout << endl << dl.cursor_datum() << " is less than " << dl2.cursor_datum();
    else
        cout << endl << dl.cursor_datum() << " is not less than " << dl2.cursor_datum();
    if(dl.cursor_datum() == (dl2.cursor_datum()))
        cout << endl << dl.cursor_datum() << " is equal to " << dl2.cursor_datum();
    else
        cout << endl << dl.cursor_datum() << " is not equal to " << dl2.cursor_datum();
   cout << endl << "\nUsing square bracket [] to access elements of Mystring objects. ";

    char c = dl.cursor_datum()[1];
    cout << endl << "The socond element of "  << dl.cursor_datum() << " is: " << c;
    
    dl.cursor_datum()[1] = 'o';
    c = dl.cursor_datum()[1];
    cout << endl << "The socond element of "  << dl.cursor_datum() << " is: " << c;

    cout << endl << "\nUsing << to display key/datum pairs in a Dictionary list: \n";
    /* The following line is expected to display the content of the linked list
     * dl2 -- key/datum pairs. It should display:
     *   8001  Allen
     *   8002  Peter
     *   8003  Sam
     *   8004  PointyHair
     */
    cout << dl2;
 
    cout << endl << "\nUsing [] to display the datum only: \n";
    /* The following line is expected to display the content of the linked list
     * dl2 -- datum. It should display:
     *   Allen
     *   Peter
     *   Sam
     *   PointyHair
     */
    
    for(int i =0; i < dl2.size(); i++)
        cout << dl2[i] << endl;
    
    cout << endl << "\nUsing [] to display sequence of charaters in a datum: \n";
    /* The following line is expected to display the characters in the first node
     * of the dictionary. It should display:
     *   A
     *   l
     *   l
     *   e
     *   n
     */
    cout << dl2[0][0] << endl;
    cout << dl2[0][1] << endl;
    cout << dl2[0][2] << endl;
    cout << dl2[0][3] << endl;
    cout << dl2[0][4] << endl;
    
    cout << "\n\n***----Finished tests for overloading operators ----------***\n\n";
}
#endif
